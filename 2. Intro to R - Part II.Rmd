---
title: "Intro to R - Part II"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

# Data sampling

*sample()* function takes a sample of the specified size from the elements of x.

```{r}
# create a vector with values from 1 to 10
x <- 1:10

# create a sample of size 5 from the vector
sample(x, size = 5)
```

If we want a sample with a size greater than the original vector, we need to pass the argument *replace=TRUE*.

```{r}
# create a sample of size 20 from the vector, where duplicates are allowed
sample(x, size = 20, replace = TRUE)
```

If the previous code is ran multiple times, it will always produce  different result. If we want to have the same sample each time, we need to specify the seed number (used by the random number generator).

```{r}
# set seed and create two sample of size 20 from the vector, where duplicates are allowed
set.seed(10)
sample(x, size = 20, replace = TRUE)
set.seed(10)
sample(x, size = 20, replace = TRUE)
```

# Matrices

Matrices are objects with elements arranged in a two-dimensional rectangular layout. They contain elements of the same type. A matrix is created with a function *matrix()*. Similar to vectors, elements are indexed and a specific element can be retrieved by its index. *nrow()* returns number of rows, and *ncol()* returns number of columns in a matrix.

```{r}
# create a 2 x 4 matrix with values from 8 to 1, filled by rows
a <- matrix(8:1, nrow = 2, ncol = 4, byrow = TRUE)
a

# get the first row
a[1, ]

# get the element from row 1, column 2
a[1,2]

# get number of rows
nrow(a)

# get number of columns
ncol(a)
```

All matrix operations can be applied.

```{r}
# create two matrices of the same dimension
matrix1 <- matrix(c(3, 9, -1, 4), nrow = 2)
matrix1
matrix2 <- matrix(c(5, 2, 0, 9), nrow = 2)
matrix2

# add matrix2 to matrix1
matrix1 + matrix2
```

Transposing a matrix can be achieved via the *t()* function.

```{r}
# transpose a matrix
t(matrix1)
```

# Lists

Lists are objects which contain elements of different types, such as numbers, strings, vectors, and even functions and other lists. A list is created by using the function *list()*. A specific element can be accessed by its index or its name. *length()* returns the number of elements in a list.

```{r}
# create a new list with attributes: passport, age, diplomatic
traveler1 <- list(passport = "P123123", age = 34, diplomatic = TRUE)
traveler1

# get the 2nd element
traveler1[2]

# get the value of the 2nd element
traveler1[[2]]

# get the value of the age element
traveler1$age

# get the list length
length(traveler1)
```

*append()* function is similar to the *c()* function. But *append()* is different in the sense that it allows for values to be inserted into a vector after a certain position.

```{r}
# add new list after the 2nd element
traveler1 <- append(traveler1, list(country = "AUS"), after=2)
length(traveler1)
traveler1
```

An element is deleted by assigning NULL to it.

```{r}
# delete 3rd element
traveler1[[3]] <- NULL
length(traveler1)
traveler1
```

When the concatenation function *c()* is given list arguments, the result is also a list containing all elements from the passed lists joined in a sequence.

```{r}
# concatinate two lists
traveler2 <- list(passport = "P456456", age = 14, diplomatic = FALSE)
travelers <- c(traveler1, traveler2)
travelers
```

*is.list()* returns TRUE if an object is of type list.

```{r}
# check if travelers is a list
is.list(travelers)
```

*names()* function retrieves names of all list elements.

```{r}
# get names of all list elements
names(travelers)

# get elements with name 'age'
travelers[names(travelers) == "age"]
```

# Loops and branching

## For each loop

Iterates through each element of the provided vector. *break* stops the loop, while *next* stops the current iteration.

```{r}
# print all odd numbers from 1 to 10 using for each loop
for (i in 1:10) {
  if (i %% 2 == 1) {
    print(paste(i,"is odd number"))
  }
}
```

## While loop

```{r}
# print all odd numbers from 1 to 10 using while loop
i <- 1
while (i <= 10) {
 if (i %% 2 == 1) {
    print(paste(i,"is odd number"))
  }
  i <- i + 1
}
```

## Task 1

Create a 2 x 3 matrix with the following elements: 3, 9, -1, 4, 2, 6 (by row). Print only the positive values from the first row.

Answer:
```{r}
matrix1 <- matrix(c(3, 9, -1, 4, 2, 6), nrow = 2)

for (i in matrix1[1,]) {
  if (i > 0) {
    print(i)
  }
}
```

## if-else
```{r}
# use ifelse function to create a new attribute called 'request' with the value 'assistance required' if a traveler is younger than 10 years, and the value 'no special requests' otherwise
traveler1$request <- ifelse(test = traveler1$age < 10,
                            yes = "assistance required",
                            no = "no special requests")
traveler1
```

# User-defined functions and apply

The structure of a function is given below.

```
myfunction <- function(arg1, arg2, ... ){
  statements
  return(object)
}
```

The last expression evaluated in a function is a return value.

```{r}
# create a function that adds two numbers. The default value for the second argument is 1
add <- function(x, y = 1){
  x + y
}

add(2)
add(2, 3)
```

*return(value)* stops the execution of a function and returns a value.

```{r}
# create a function returning an absolute value of x. Return the result using the return() function
my_abs <- function(x) {
  if (x > 0) {
    return(x)
  }
  return(-x)
}

my_abs(5)
my_abs(-5)
```

## Applying a function over rows and columns in data frame

We can apply a custom function to a data frame (similar can be done with vectors, lists and matrices). The *apply()* function accepts data frame as the first argument. The second argument is called MARGIN and it defines how the function is applied. If MARGIN=1, it applies over rows, whereas with MARGIN=2, it works over columns. When MARGIN=c(1,2), it applies to both rows and columns. 

```{r}
# load the data "data/beatles_v2.csv"
beatles <- read.csv("data/beatles_v2.csv", stringsAsFactors = FALSE)

# get the number of characters in the song title "Yellow Submarine"
nchar("Yellow Submarine")

# get the number of characters of the first 10 songs
apply(beatles[1:10, 1, drop=FALSE], 1, nchar)
```

NOTE: When subsetting the dataframe to only one column (like in the previous example), the return value is a vector. If we want to get a dataframe (with one column) as a return value, we need to supply "drop=FALSE" argument. This will tell R not to convert the result to a vector, but to return the dataframe.

```{r}
# calculate the mean value of the duration and Top.50.Billboard values of all songs from 1963
apply(beatles[beatles$Year == 1963, c(4,9)], 2, mean)

# calculate the mean value of the duration and Top.50.Billboard values that are not NAs of all songs from 1963
mean.with.na <- function(x) {
  mean(x, na.rm = TRUE)
}

apply(beatles[beatles$Year == 1963, c(4,9)], 2, mean.with.na)
```

# Working with tables

*table()* builds a contingency table of the counts at each attribute value.

```{r}
# create a contingency table of column Year values
year.counts <- table(beatles$Year)
year.counts

# get the 4th element from the table
year.counts[4]

# store the 4th element from the table in a variable
x <- year.counts[4]
x

# convert the variable to numeric 
y <- as.numeric(x)
y
```

Sort the table by the count value.

```{r}
# sort the table in the descending order
sort(year.counts, decreasing = T)
```

Table of proportions can be obtained by using the *prop.table()* function.

```{r}
# get the proportions table for the values of the Year column
year.counts.prop <- prop.table(year.counts)
year.counts.prop

# sort the proportions table in the descending order
sort(year.counts.prop, decreasing = T)

# get the proportions table for the values of the Year column, but limiting number of digits to 2
round(year.counts.prop, digits = 2)
```

*xtabs()* creates a contingency table using formula style input.

```{r}
# create a contingency table Top.50.Billboard vs. Year
xtabs(~Top.50.Billboard + Year, beatles)
```

# Manipulating data frames

## Adding new rows and columns

A column can be added by assigning values to a new column name in the data frame. 

```{r}
# create a new column On.album and set FALSE for all songs
beatles$On.album <- FALSE

head(beatles)
```

By using the *cbind()* function, you can join two data frames by columns.

```{r}
# create a new data frame with two columns (with sample data)
additional.columns <- data.frame(
  Platinum = sample(c(TRUE, FALSE), 310, replace = TRUE),
  Score = sample(5:10, 310, replace = TRUE)
)

# combine two data frames
beatles <- cbind(beatles, additional.columns)
head(beatles)
```

Rows are added by using the *rbind()* function. 

```{r}
# get the first song
new.song <- beatles[1, ]

# add the song to the end of the data frame
beatles <- rbind(beatles, new.song)
tail(beatles)

# add the song after the 3rd song in the data frame 
beatles <- rbind(beatles[1:3, ],
                           new.song, 
                           beatles[4:nrow(beatles), ])
head(beatles)
```

## Removing columns and rows

A column is removed by assigning a NULL to it.

```{r}
# remove the attribute On.album
beatles$On.album <- NULL
names(beatles)
```

Another way of removing columns is to form a set of the columns you want to remove and keep the complement of that set. The complement of a set is given by the '-' operator.

```{r}
# remove columns Platinum (at index 10) and Score (at index 11)
beatles <- beatles[,-c(10, 11)]
names(beatles)
```

Using the same method, rows can be removed.

```{r}
# create a subset of the data frame without songs in rows 2, 4 and 6 
beatles1 <- beatles[-c(2, 4, 6), ]
head(beatles1)

# create a subset of the data frame without songs in rows from 1 to 8 
beatles2 <- beatles[-(1:8), ]
head(beatles2)
```

## Updating column and row names

*colnames()* function returns all column names. A column name is changed by assigning a new name to it.

```{r}
# get column names
colnames(beatles)

# change name of the column 'Genre' to 'Song.genre'
genreIndex <- which(colnames(beatles) == "Genre")
colnames(beatles)[genreIndex] <- "Song.genre"
colnames(beatles)
```

```{r}
# change name of the column at the index 6 to 'Genre'
colnames(beatles)[6] <- "Genre"
colnames(beatles)
```

*rownames()* function returns all row names. A row name is changed by assigning a new name to it.

```{r}
# change row names to a string containing word 'song' and a song order number
rownames(beatles) <- paste("song", 1:nrow(beatles))
head(beatles)

# change row names to a string containing order number
rownames(beatles) <- c(1:nrow(beatles))
head(beatles)
```

## Retrieving and changing values

Parts of a data frame can be selected in different ways.

```{r}
# get songs in rows from 1 to 5, but only attributes Title and Album.debut
first.songs <- beatles[1:5, c("Title", "Album.debut")]
first.songs

# get the songs from year 1964 not having McCartney as a lead vocal
indexes <- which((beatles$Year == "1964") & (beatles$Lead.vocal != "McCartney"))
selected.songs <- beatles[indexes, ]
head(selected.songs)

# get the songs from year 1958, but only attributes Title and Album.debut
songs.1958 <- subset(beatles, Year == 1958, c("Title", "Album.debut"))
head(songs.1958)
```

Values of specific columns/rows can be changed by assigning new values to them.

```{r}
# create a vector of logical values denoting whether there the attribute Album.debut has a value or not
empty.album.debut <- beatles$Album.debut == ""

# songs at indexes of all TRUE value will have their Album.debut attribute set to 'empty'
beatles$Album.debut[empty.album.debut] <- "empty"

# set the value back to empty string
beatles$Album.debut[empty.album.debut] <- ""
```

## Saving dataset

```{r}
# save dataset to a CSV file, but without the row names (row numbers) column
write.csv(beatles, "data/p2.csv", row.names = F)

# save R object for the next session into file "p2.RData"
saveRDS(beatles, "p2.RData")

# restore R object from the file "p2.RData" in the next session
p2 <- readRDS("p2.RData")
```

## Task 2

Create a new column in the *beatles* data frame called *Billboard.hit* having TRUE for all songs that were in the Top 50 Billboard (songs that have the Top.50.Billboard defined), and FALSE for all other songs (not having this value set).

Answer:
```{r}
beatles$Billboard.hit <- FALSE
beatles$Billboard.hit[!is.na(beatles$Top.50.Billboard)] <- TRUE
head(beatles)
```


####
# Homework

## Task 1

Create a 2 x 3 matrix with the following elements: 3, 9, -1, 4, 2, 6. Print only the positive values from the first row.

Answer:
```{r}
matrix1 <- matrix(c(3, 9, -1, 4, 2, 6), nrow = 2)

for (i in matrix1[1,]) {
  if (i > 0) {
    print(i)
  }
}
```